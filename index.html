// ======== Kh·ªüi t·∫°o gi√° tr·ªã handX m∆∞·ª£t ========
let smoothHandX = 0.5;

// ======== H√†m animate ========
function animate() {
    requestAnimationFrame(animate);
    const time = Date.now() * 0.001;
    const speed = 0.06;

    // Smooth hand movement + gi·ªõi h·∫°n bi√™n
    smoothHandX += (handX - smoothHandX) * 0.2;
    const clampedX = Math.min(Math.max(smoothHandX, 0.1), 0.9);
    const handRotY = (clampedX - 0.5) * 6.5; // xoay c√¢y theo tay

    // C·∫≠p nh·∫≠t c√°c nh√≥m particle
    updateParticleGroup(groupGold, state, speed, handRotY, time, false);
    updateParticleGroup(groupRed, state, speed, handRotY, time, false);
    updateParticleGroup(groupGift, state, speed, handRotY, time, false);

    // Tr√°i tim
    if (state === 'HEART') {
        heartRotation += 0.01;
        loveTextMesh.visible = true;
        const pulse = 1 + Math.sin(time * 3) * 0.05;
        loveTextMesh.scale.set(pulse, pulse, 1);
        loveTextMesh.lookAt(camera.position);
    }

    // ·∫¢nh
    photoMeshes.forEach((mesh, i) => {
        if (!mesh.material.map && photoTextures[i]) {
            mesh.material.map = photoTextures[i];
            mesh.material.needsUpdate = true;
        }
    });

    // Hi·ªÉn th·ªã c√°c tr·∫°ng th√°i
    if (state === 'TREE') {
        if (loveTextMesh) loveTextMesh.visible = false;
        titleMesh.visible = true;
        starMesh.visible = true;
        titleMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
        starMesh.rotation.z -= 0.02;
        photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); m.visible = false; });
    } else if (state === 'HEART') {
        titleMesh.visible = false; starMesh.visible = false;
        photoMeshes.forEach(m => { m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); m.visible = false; });
    } else if (state === 'EXPLODE') {
        titleMesh.visible = false; starMesh.visible = false;
        const baseAngle = groupGold.rotation.y;
        const angleStep = (Math.PI * 2) / photoMeshes.length;
        let bestIdx = 0; let maxZ = -999;

        photoMeshes.forEach((mesh, i) => {
            mesh.visible = true;
            const angle = baseAngle + i * angleStep;
            const x = Math.sin(angle) * CONFIG.photoOrbitRadius;
            const z = Math.cos(angle) * CONFIG.photoOrbitRadius;
            const y = Math.sin(time + i) * 3;
            mesh.position.lerp(new THREE.Vector3(x, y, z), 0.1);
            mesh.lookAt(camera.position);

            if (z > maxZ) { maxZ = z; bestIdx = i; }

            if (z > 5) {
                const distScale = 1.0 + (z / CONFIG.photoOrbitRadius) * 0.8;
                mesh.scale.lerp(new THREE.Vector3(distScale, distScale, distScale), 0.1);
            } else {
                mesh.scale.lerp(new THREE.Vector3(0.6, 0.6, 0.6), 0.1);
            }
        });
        selectedIndex = bestIdx;
    } else if (state === 'PHOTO') {
        photoMeshes.forEach((mesh, i) => {
            if (i === selectedIndex) {
                mesh.position.lerp(new THREE.Vector3(0, 0, 60), 0.1);
                mesh.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1);
                mesh.lookAt(camera.position);
                mesh.rotation.z = 0;
            } else {
                mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
            }
        });
    }

    renderer.render(scene, camera);
}

// ======== H√†m startSystem m·ªõi ========
function startSystem() {
    document.getElementById('btnStart').style.display = 'none';
    bgMusic.play().catch(e => console.log(e));

    init3D(); // Kh·ªüi t·∫°o 3D

    const video = document.getElementsByClassName('input_video')[0];
    const canvas = document.getElementById('camera-preview');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

    hands.onResults(results => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (results.image) ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

        // Ki·ªÉm tra 2 tay gh√©p tr√°i tim
        if (results.multiHandLandmarks.length === 2) {
            const hand1 = results.multiHandLandmarks[0];
            const hand2 = results.multiHandLandmarks[1];
            const thumbDist = Math.hypot(hand1[4].x - hand2[4].x, hand1[4].y - hand2[4].y);
            const indexDist = Math.hypot(hand1[8].x - hand2[8].x, hand1[8].y - hand2[8].y);
            const avgY1 = (hand1[4].y + hand1[8].y)/2;
            const avgY2 = (hand2[4].y + hand2[8].y)/2;
            if (thumbDist < 0.08 && indexDist > 0.15 && Math.abs(avgY1-avgY2)<0.1) {
                state = 'HEART';
                statusDiv.innerText = "ü§≤ 2 Tay Gh√©p Tr√°i Tim"; statusDiv.style.color="#FF69B4";
                return;
            }
        }

        if (results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            handX = lm[9].x;
            const tips = [8,12,16,20], wrist=lm[0];
            let openDist=0; tips.forEach(i=>openDist+=Math.hypot(lm[i].x-wrist.x,lm[i].y-wrist.y));
            const avgDist=openDist/4;
            const pinchDist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);

            if (avgDist < 0.25) { state='TREE'; statusDiv.innerText="‚úä Thu C√¢y Th√¥ng"; statusDiv.style.color="#FFD700"; }
            else if (pinchDist < 0.05) { state='PHOTO'; statusDiv.innerText="üëå Xem ·∫¢nh"; statusDiv.style.color="#00FFFF"; }
            else { state='EXPLODE'; statusDiv.innerText="üñê Bung Qu√† & ·∫¢nh"; statusDiv.style.color="#FFA500"; }
        } else {
            state='TREE';
            statusDiv.innerText="üéÑ Giang Sinh An Lanh üéÑ"; statusDiv.style.color="#FFF";
        }
    });

    const cameraUtils = new Camera(video, {
        onFrame: async () => { await hands.send({image:video}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    animate(); // start render
}
